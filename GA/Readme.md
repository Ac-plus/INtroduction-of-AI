# 遗传算法解决函数优化问题

## 一、实验内容
遗传算法（genetic algorithms，GA）是一类借鉴生物界自然选择和自然遗传机制的随机搜索算法，非常适用于处理传统搜索方法难以解决的复杂和非线性优化问题，可广泛应用于组合优化、机器学习、自适应控制、规划设计和人工生命等领域。
本次实验即需要通过遗传算法求解下面Rastrigin函数的优化问题：

![image](https://github.com/Ac-plus/INtroduction-of-AI/assets/104805387/2dc2d715-a629-485a-8860-8a9c93c3fa89)

 
即在 $-5≤x_i≤5,i=1,2$ 的范围上求解函数的最小值。

## 二、实验原理与步骤
### 2.1 实验原理
遗传算法的基本思想是在求解问题时从多个解开始，然后通过一定的法则进行逐步迭代以产生新的解，如图2-1所示。

![image](https://github.com/Ac-plus/INtroduction-of-AI/assets/104805387/835857ce-e107-4151-a18d-061695f0451b)

图2-1 遗传算法过程

染色体作为遗传物质的主要载体，即多个基因的集合，其内部表现（即基因型）是某种基因组合，它决定了个体的形状的外部表现，因此，在一开始需要实现从表现型到基因型的映射即编码工作。由于仿照基因编码的工作很复杂，我们往往进行简化，如二进制编码。
具体来看，初代种群产生之后，按照适者生存和优胜劣汰的原理，逐代（generation）演化产生出越来越好的近似解，在每一代，根据问题域中个体的适应度（fitness）大小选择（selection）个体，并借助于自然遗传学的遗传算子（genetic operators）进行组合交叉（crossover）和变异（mutation），产生出代表新的解集的种群。
这个过程将导致种群像自然进化一样的后生代种群比前代更加适应于环境，末代种群中的最优个体经过解码（decoding），可以作为问题近似最优解。

### 2.2 实验步骤
#### 2.2.1 整体分析
如图2-3所示为Rastrigin函数的图像，由一个个连续的波峰和波谷组成。

![image](https://github.com/Ac-plus/INtroduction-of-AI/assets/104805387/cef3249b-183e-4274-a432-dc45e602ebc5)

图2-3 Ras函数的三维图像

由此推测得出：函数的最小值位于(0,0)点处，其最小值为0.为了求得这个值，结合2.1中所述的原理，设计了如图2-4所示的整体框架流程图。

![image](https://github.com/Ac-plus/INtroduction-of-AI/assets/104805387/04817ca0-b904-4c78-9984-3b731042e3c9)

图2-4 算法流程图
#### 2.2.2 设计实现
首先需要构造一个种群，然后进行初始化种群操作，为种群中的所有个体创建基因序列，进而开始繁衍获得下一代。获得下一代需要经过以下两个步骤：

（1）产生后代

种群中的每一个个体与种群中的另一个随机个体繁衍获得孩子。暂时先默认孩子接收父亲的基因。但是繁殖过程中孩子的基因可能发生交叉（从孩子的基因的一个随机位置开始，该位置后的基因变为母亲在同样位置之后的基因）和变异（将孩子的基因的某个随机片段按位取反）。这样以后个体数量变为原本的2倍。

（2）自然选择

接下来要进行选择，选择适应度较高的一半个体存活。

![image](https://github.com/Ac-plus/INtroduction-of-AI/assets/104805387/9ab8a85c-248f-4dea-89b0-7e3b256b01cc)

图2-5 自然选择的转化过程

个体的适应度fitness(x)用函数的计算结果表示，在带入到函数的自变量中求解之前，先把个体的基因转换成十进制的数字。转换方式如图2-5所示。

（3）计算适应度

根据自然选择拆分出的前后两段基因序列片段作为x和y值代入fitness函数求解每个个体的适应度。实现过程如图2-6所示。

![image](https://github.com/Ac-plus/INtroduction-of-AI/assets/104805387/0528acbd-a0d5-4c8e-b8bd-c4cadf498b94)

图2-6 适应度函数

（4）排序和取优

求得适应度之后进行排序，将所有个体按适应度升序排列，即可计算最小值。排序之后，越前面的个体就是越符合要求的个体，此时只要选择前面一半个体作为新一代个体即可。这种方法可以保证最优秀的个体一定可以被保留下来。最后逐步迭代后，即可得到最优解。

#### 2.2.3 环境配置

实验配置的各项参数如表1所示。

表1 实验环境配置

|项目|	操作系统	|处理器|	程序语言|	
|---|---|---|---|
|参数|	Ubuntu 20.0|	Intel Core i7|

#### 2.2.4 操作步骤

根据2.1、2.2.1和2.2.2等部分的描述，本实验的具体步骤如下：

（1）配置实验环境；

（2）分析问题需求；

（3）设计函数优化的GA算法，画出流程图，分析伪代码；

（4）根据流程图编写完整程序；

（5）分析实验结果。

## 三、实验结果与分析
### 3.1 参数设置

编写test.py测试程序，定义Rastrigin函数，取左界和右界分别为-5和5。之后设置种群大小、变异率等参数进行遗传迭代，如表2所示。

表2 测试参数配置

|参数名	|种群大小|	变异率|	交叉率|	基因序列长度|	进化代数|
|---|---|---|---|---|---|
|数值|	300|	0.05|	0.8|	128|	100|

### 3.2 实验结果
运行程序后，会逐行输出每一代最优个体的x, y和Ras(x, y)的优化值。如图3-1所示，这里选取前10代、中间10代和后10代的输出截图进行展示。


### 3.3 结果分析
#### 3.3.1 逐代结果分析
对3.2测试样例中的每代结果数据列成坐标图，以分析优化值的变化走向，如图3-2—图3-6所示。

![image](https://github.com/Ac-plus/INtroduction-of-AI/assets/104805387/78ca7ac3-286b-441f-8e80-368b1b772474)


图3-2 第1-20代结果变化图

从第1代到第20代，优化值从1.6左右，从第4-7代迅速降低，说明在这附近的筛选选择到了更优的变异个体。

![image](https://github.com/Ac-plus/INtroduction-of-AI/assets/104805387/4cb0992b-ad51-4ec8-86d4-fda45939b6a7)

图3-3 第21-40代结果变化图

从第21代到第40代，优化值从4.634×10^(-5)左右，从第22代开始迅速降低，到第25、30代开始又出现了两次小幅度降低。说明在3个位置附近的筛选选择到了更优的变异个体，但筛选变异程度有差别。

![image](https://github.com/Ac-plus/INtroduction-of-AI/assets/104805387/6058d1de-2afc-4a67-8b43-586fa4a5e2cc)

图3-4 第41-60代结果变化图

从第41代到第60代，优化值从2.841×10^(-8)左右，从第43代开始迅速降低，到第46、50、55代开始又出现了3次小幅度降低。说明在以上4个位置附近的筛选选择到了更优的变异个体，但筛选变异程度有差别。

![image](https://github.com/Ac-plus/INtroduction-of-AI/assets/104805387/fcddadc0-4725-4f6e-8114-26fec921894d)

图3-5 第61-80代结果变化图

从第61代到第80代，优化值从8.970×10^(-11)左右，从第62代开始迅速降低，到第66代开始又出现了一次小幅度降低。说明在以上两个位置附近的筛选选择到了更优的变异个体，但筛选变异程度有差别。除此之外的其他代结果之间基本改变不大。

![image](https://github.com/Ac-plus/INtroduction-of-AI/assets/104805387/d8ef2205-6e54-4f94-b4d8-d9bce9a5fecc)

图3-6 第81-100代结果变化图

从第81代到第100代，优化值从1.11×10^(-12)左右，从第91-92代开始迅速降低到0。说明在以上位置附近的筛选选择到了更优的变异个体。至此，已经得到了函数优化问题的最优解。
需要指出的是，并非每次进行测试程序都会给出一样的结果，因为每次的交叉、变异和选择的方向都是由概率决定的随机事件。例如，最终有可能无法得到0这个答案，可能有所浮动（但浮动范围非常小）。

## 四、实验总结

本实验中，通过交叉、编译、迭代等方法，实现了基于遗传算法求解函数最小值，然后对结果给予分析。所编写的程序能够通过逐代运算，求解出给定函数的最小值。综上所述，本次实验大体成功。





